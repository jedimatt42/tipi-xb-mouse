;
; TIPI Extended BASIC mouse driver compatible with Mechatronics Mouse interface
;
; CALL INIT::CALL LOAD("TIPI.TMOUSE/O")
; 
; CALL LINK("MOUSE0") 
; -- Will block until mouse button 1 is pressed. A subsequent
;    CALL PEEK(10000,VPOS,HPOS) will read location data.
;    MKEY will be 255.
;    Shows mouse sprite when active. Hides mouse sprite on return.
;
; CALL LINK("MOUSE1")
; -- Install an interupt service routine to update the mouse location and
;    button status. 
;    Mouse sprite is activated. Control flow returns to the calling XB
;    program. Subsequent CALL PEEK(10000,VPOS,HPOS,MKEY) calls will
;    provide the updated status. 
;
; CALL LINK("MCLR")
; -- Uninstalls the interrupt service routine, and hides the mouse sprite.
;
; CALL LOAD(10003,VHOME,HHOME)
; -- stores the value of VHOME and HHOME in address 10003 and 10004. The
;    driver will move the pointer to this position if second mouse button
;    is pressed.
;
; CALL LOAD(10005,LEFT,RIGHT,TOP,BOTTOM)
; -- stores a bounding box to contain the pointer.
;


	def MOUSE0
	def MOUSE1
	def MCLR


MAILBOX	EQU	>2710
VPOS	EQU	MAILBOX		; Vertical position of pointer
HPOS	EQU	MAILBOX+1	; Horizontal position of pointer
MKEY	EQU	MAILBOX+2	; 255 if mouse 1 pressed, 0 if not
VHOME	EQU	MAILBOX+3	; Vertical home for pointer (right mouse button action)
HHOME	EQU	MAILBOX+4	; Horizontal home for pointer (right mouse button action)
LMARG	EQU	MAILBOX+5	; Left margin - default 0
RMARG	EQU	MAILBOX+6	; Right margin - default 255
TMARG	EQU	MAILBOX+7	; Top margin - default 0
BMARG	EQU	MAILBOX+8	; Bottom margin - default 192

; Message code for mouse request
MOUREQ	BYTE	>20
V255	BYTE	>FF
; receive buffer
MOUBUF  BSS	3
	EVEN

SENDMSG	EQU	>4012
RECVMSG	EQU	>4010

; once discovered, will hold crubase to reduce lookup cost
CRUBASE	DATA	>0000

MWS	BSS	>20		; MOUSE-WORKSPACE
MWSR2	EQU	MWS+4
MWSR3	EQU	MWS+6
MWSR4	EQU	MWS+8

WORKSV	DATA	0

; TIPI mouse button bits
MBLEFT	EQU	>01
MBRIGHT	EQU	>02
MBMID	EQU	>04

GPLWS	EQU	>83E0
GPLWSR1	EQU	>83E2

; XB Sprite Attribute list
SPRITES EQU	>80*6
; VDP Write Data pointer
VDPWD	EQU	>8C00
VDPWA	EQU	>8C02
VDPST	EQU	>8802

; User Defined Interrupt hook
USRINT	EQU	>83C4


; XB entry points
MOUSE0	stwp	R10
	mov	R10,@WORKSV
	lwpi	MWS

	; Now we are free to mouse around

	MOV	@CRUBASE,@CRUBASE	; do we need to find the crubase?
	JNE	VBLP1
	BL	@FINDCRU

	; Loop on status register until VBLANK
VBLP1	CLR	R12
	TB	2
	JEQ	VBLP1			; wait until VBLANK
	MOVB	@VDPST,R12		; read the status for this to work correctly

	BL	@READM
	BL	@UPDATE

	MOVB	@MKEY,@MKEY
	JEQ	VBLP1


	; restore workspace with all the unmodified return pointers for CALL LINK
	MOV	@WORKSV,@$+8	; this writes WP into next instruction, first param, as though it was literal
	LWPI	>AAAA
	RT

; Install User interrupt routine to update mouse data
MOUSE1	stwp	R10
	mov	R10,@WORKSV
	lwpi	MWS

	BL	@FINDCRU

	LI	R0,MYINTR
	MOV	R0,@USRINT

	; restore workspace with all the unmodified return pointers for CALL LINK
	MOV	@WORKSV,@$+8	; this writes WP into next instruction, first param, as though it was literal
	LWPI	>AAAA
	RT

; My User defined interrupt routine
; System interupt routine calls with WS set to GPLWS
; with BL, so preserve R11 and RT to return to console ROM.
MYINTR	lwpi	MWS

	BL	@READM
	BL	@UPDATE

	LWPI	>83E0		; we know we are always called from that workspace
	RT

; Clear user defined interrupt routine
MCLR	stwp	R10
	mov	R10,@WORKSV
	lwpi	MWS

	CLR	@USRINT
	CLR	@VPOS
	MOVB	@VPOS,@MKEY
	LIMI	0

	; restore workspace with all the unmodified return pointers for CALL LINK
	MOV	@WORKSV,@$+8	; this writes WP into next instruction, first param, as though it was literal
	LWPI	>AAAA
	RT


; Utility functions and support data

TIPI
	BYTE	>04,'T','I','P','I'
	EVEN

; If TIPI card is available, @CRUBASE will hold TIPI's cru address.
;   otherwise it will remain 0.
FINDCRU
	LI	R12,>1000
ISDSR	
	SBO	0
	LI	R0,>AA00
	CB	@>4000,R0
	JNE	NEXTCARD	; no dsr rom header
	MOV	@>4008,R0
	JEQ	NEXTCARD	; end of DSR list
	AI	R0,4		; R0 now points to DSR name
	LI	R1,TIPI
	LI	R2,5		; compare 5 bytes of name string
TEST
	CB	*R0+,*R1+
	JNE	NEXTCARD
	DEC	R2
	JNE	TEST
	SBZ	0		; Found TIPI!
	MOV	R12,@CRUBASE
	RT

NEXTCARD
	SBZ	0
	AI	R12,>0100
	CI	R12,>2000
	JEQ	NOTIPI
	JMP	ISDSR
	
NOTIPI
	CLR	@CRUBASE
	RT
 
; Read mouse location and status from TIPI
; Afterwards MOUBUF contains x, y, buttons
READM	MOV	@CRUBASE,R12	; enable tipi device
	SBO	0

	MOV	R11,R15
	LI	R0,>0001	; send message requesting mouse DATA
	LI	R1,MOUREQ
	MOV	@SENDMSG,R4
	BL	*R4

	CLR	R0		; receive mouse data back 
	LI	R1,MOUBUF	; set buffer location
	MOV	@RECVMSG,R4
	BL	*R4

	SBZ	0		; disable tipi device
	MOV	R15,R11
	RT

; Update VPOS HPOS and MKEY based on data read from TIPI
; MOUBUF [x-delta, y-delta, button-bits]
; location is almost XB style.. 0,0 top left, 255,255 bottom right
UPDATE	CLR	R0
	; process the X value from TIPI
	MOVB	@MOUBUF,R0
	SRA	R0,8		; x in R0, needs to be used to modify HPOS, signed
	CLR	R1
	MOVB	@HPOS,R1
	SWPB	R1		; old hpos in R1, this is always positive.. 
	A	R0,R1		; new HPOS in R1

	; fit it within the bounding box.
	; check right-hand limit
	CLR	R2
	MOVB	@RMARG,R2
	SWPB	R2
	C	R1,R2
	JLT	SKIPRM
	; reset to right margin limit
	CLR	R1
	MOVB	@RMARG,R1
	SWPB	R1
	JMP	STOREH		; we were too big, so no need to check if we were too small

	; check for left-hand limit
SKIPRM	CLR	R2
	MOVB	@LMARG,R2
	SWPB	R2
	C	R1,R2
	JGT	STOREH
	; reset to left limit
	CLR	R1
	MOVB	@LMARG,R1
	SWPB	R1

STOREH	SWPB	R1
	MOVB	R1,@HPOS
	
	; apply vertical change
	CLR	R0
	MOVB	@MOUBUF+1,R0
	SRA	R0,8		; delta y as signed interface
	CLR	R1
	MOVB	@VPOS,R1
	SWPB	R1
	A	R0,R1		; new VPOS in R1

	; check bottom bound
	CLR	R2
	MOVB	@BMARG,R2
	SWPB	R2
	C	R1,R2
	JLT	SKIPBM
	; reset to bottom limit
	CLR	R1
	MOVB	@BMARG,R1
	SWPB	R1
	JMP	STOREV

	; check top limit
SKIPBM	CLR	R2
	MOVB	@TMARG,R2
	SWPB	R2
	C	R1,R2
	JGT	STOREV
	; reset to top limit
	CLR	R1
	MOVB	@TMARG,R1
	SWPB	R1

STOREV	SWPB	R1
	MOVB	R1,@VPOS


	; Set sprite location
	LI	R0,SPRITES
	LI	R1,>4000
	SOC	R1,R0		; designate a write to vdp memory address
	; Usually need interrupts off for VDP, but imperically, they are off already when 
	; CALL LINK is executing.
	SWPB	R0
	MOVB	R0,@VDPWA
	SWPB	R0
	MOVB	R0,@VDPWA
	; NOP			; I don't believe I need the NOP cause some of it is a myth.
	MOVB	@VPOS,@VDPWD	; write row for sprite #1
	MOVB	@HPOS,@VDPWD	; write column for sprite #1

	; update left mouse button
	CLR	R0
	MOVB	@MOUBUF+2,R0
	SWPB	R0
	CLR	@MKEY
	ANDI	R0,MBLEFT
	JEQ	RBUT
	MOVB	@V255,@MKEY

	; JUMP to VHOME,HHOME if right mouse button
RBUT	CLR	R0
	MOVB	@MOUBUF+2,R0
	SWPB	R0
	ANDI	R0,MBRIGHT
	JEQ	UDONE
	MOVB	@HHOME,@HPOS
	MOVB	@VHOME,@VPOS

UDONE	RT

; End of source
	END