;
; TIPI Extended BASIC mouse driver compatible with Mechatronics Mouse interface
;
; CALL INIT::CALL LOAD("TIPI.TMOUSE/O")
; 
; CALL LINK("MOUSE0") 
; -- Will block until mouse button 1 is pressed. A subsequent
;    CALL PEEK(10000,VPOS,HPOS) will read location data.
;    MKEY will be 255.
;    Shows mouse sprite when active. Hides mouse sprite on return.
;
; CALL LINK("MOUSE1")
; -- Install an interupt service routine to update the mouse location and
;    button status. 
;    Mouse sprite is activated. Control flow returns to the calling XB
;    program. Subsequent CALL PEEK(10000,VPOS,HPOS,MKEY) calls will
;    provide the updated status. 
;
; CALL LINK("MCLR")
; -- Uninstalls the interrupt service routine, and hides the mouse sprite.
;
; CALL LOAD(10003,VHOME,HHOME)
; -- stores the value of VHOME and HHOME in address 10003 and 10004. The
;    driver will move the pointer to this position if second mouse button
;    is pressed.
;
; CALL LOAD(10005,LEFT,RIGHT,TOP,BOTTOM)
; -- stores a bounding box to contain the pointer.
;


	def MOUSE0
	def MOUSE1
	def MCLR


MAILBOX	EQU	>2710
VPOS	EQU	MAILBOX		; Vertical position of pointer
HPOS	EQU	MAILBOX+1	; Horizontal position of pointer
MKEY	EQU	MAILBOX+2	; 255 if mouse 1 pressed, 0 if not
VHOME	EQU	MAILBOX+3	; Vertical home of pointer
HHOME	EQU	MAILBOX+4	; Horizontal home of pointer
LMARG	EQU	MAILBOX+5	; Left margin - default 0
RMARG	EQU	MAILBOX+6	; Right margin - default 255
TMARG	EQU	MAILBOX+7	; Top margin - default 0
BMARG	EQU	MAILBOX+8	; Bottom margin - default 192

; Not compatible with Mechatronics driver
MKEY2	EQU	MAILBOX+9	; If 0, button 2 moves mouse to home
				;   If 255, button 2 sets VHOME like MKEY

; Message code for mouse request
MOUREQ	BYTE	>20
V255	BYTE	>FF
; receive buffer
MOUBUF  BSS	3
	EVEN

SENDMSG	EQU	>4012
RECVMSG	EQU	>4010

; once discovered, will hold crubase to reduce lookup cost
CRUBASE	DATA	>0000

MWS	BSS	>20		; MOUSE-WORKSPACE
MWSR2	EQU	MWS+4
MWSR3	EQU	MWS+6
MWSR4	EQU	MWS+8

WORKSV	DATA	0

; TIPI mouse button bits
MBLEFT	EQU	>01
MBRIGHT	EQU	>02
MBMID	EQU	>04

GPLWS	EQU	>83E0
GPLWSR1	EQU	>83E2


; XB entry points
MOUSE0	stwp	R10
	mov	R10,@WORKSV
	lwpi	MWS

	; Now we are free to mouse around

	MOV	@CRUBASE,@CRUBASE	; do we need to find the crubase?
	JNE	SKIP1
	BL	@FINDCRU

SKIP1	BL	@READM
	BL	@UPDATE

	; restore workspace with all the unmodified return pointers
	MOV	@WORKSV,@$+8	; this writes WP into next instruction, first param, as though it was literal
	LWPI	>AAAA
	RT


MOUSE1	NOP
	RT


MCLR	nop
	RT


; Utility functions and support data

TIPI
	BYTE	>04,'T','I','P','I'
	EVEN

; If TIPI card is available, @CRUBASE will hold TIPI's cru address.
;   otherwise it will remain 0.
FINDCRU
	LI	R12,>1000
ISDSR	
	SBO	0
	LI	R0,>AA00
	CB	@>4000,R0
	JNE	NEXTCARD	; no dsr rom header
	MOV	@>4008,R0
	JEQ	NEXTCARD	; end of DSR list
	AI	R0,4		; R0 now points to DSR name
	LI	R1,TIPI
	LI	R2,5		; compare 5 bytes of name string
TEST
	CB	*R0+,*R1+
	JNE	NEXTCARD
	DEC	R2
	JNE	TEST
	SBZ	0		; Found TIPI!
	MOV	R12,@CRUBASE
	RT

NEXTCARD
	SBZ	0
	AI	R12,>0100
	CI	R12,>2000
	JEQ	NOTIPI
	JMP	ISDSR
	
NOTIPI
	CLR	@CRUBASE
	RT
 
; Read mouse location and status from TIPI
; Afterwards MOUBUF contains x, y, buttons
READM	MOV	@CRUBASE,R12	; enable tipi device
	SBO	0

	MOV	R11,R15
	LI	R0,>0001	; send message requesting mouse DATA
	LI	R1,MOUREQ
	MOV	@SENDMSG,R4
	BL	*R4

	CLR	R0		; receive mouse data back 
	LI	R1,MOUBUF	; set buffer location
	MOV	@RECVMSG,R4
	BL	*R4

	SBZ	0		; disable tipi device
	MOV	R15,R11
	RT

; Update VPOS HPOS and MKEY based on data read from TIPI
UPDATE	MOV	@MOUBUF,R0
	SWPB	R0
	MOV	R0,@VPOS
	MOVB	@MOUBUF+2,@MKEY
	JEQ	SKIPU
	MOVB	@V255,@MKEY
SKIPU	RT

; End of source
	END